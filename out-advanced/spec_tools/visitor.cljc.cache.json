["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$spec-tools.visitor","~:imports",null,"~:requires",["^ ","~$form","~$spec-tools.form","~$clojure.spec.alpha","~$cljs.spec.alpha","~$impl","~$spec-tools.impl","^>","^>","~$spec-tools.parse","^?","~$s","^<","^:","^:","~$spec-tools.core","^@","~$st","^@","^<","^<","~$parse","^?"],"~:cljs.spec/speced-vars",[],"~:uses",null,"~:defs",["^ ","~$spec-dispatch",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/Users/felipe.marques/.cljs/.aot_cache/1.10.773/09B52A0/spec_tools/visitor.cljc","~:line",9,"~:column",8,"~:end-line",9,"~:end-column",21,"~:private",true,"~:arglists",["~#list",["~$quote",["^P",[["~$spec","~$accept","~$options"]]]]]],"^N",true,"^5","~$spec-tools.visitor/spec-dispatch","^I","/Users/felipe.marques/.cljs/.aot_cache/1.10.773/09B52A0/spec_tools/visitor.cljc","^M",21,"~:method-params",["^P",[["^R","^S","^T"]]],"~:protocol-impl",null,"~:arglists-meta",["^P",[null,null]],"^K",1,"~:variadic?",false,"^J",9,"~:ret-tag",["^4",[null,"~$any","~$cljs.core/Keyword"]],"^L",9,"~:max-fixed-arity",3,"~:fn-var",true,"^O",["^P",["^Q",["^P",[["^R","^S","^T"]]]]]],"~$visit-spec",["^ ","^5","~$spec-tools.visitor/visit-spec","^I","/Users/felipe.marques/.cljs/.aot_cache/1.10.773/09B52A0/spec_tools/visitor.cljc","^J",24,"^K",1,"^L",24,"^M",21,"^H",["^ ","^I","/Users/felipe.marques/.cljs/.aot_cache/1.10.773/09B52A0/spec_tools/visitor.cljc","^J",24,"^K",11,"^L",24,"^M",21],"~:tag","~$cljs.core/MultiFn"],"~$visit",["^ ","^G",null,"^H",["^ ","^I","/Users/felipe.marques/.cljs/.aot_cache/1.10.773/09B52A0/spec_tools/visitor.cljc","^J",26,"^K",7,"^L",26,"^M",12,"^O",["^P",["^Q",["^P",[["^R","^S"],["^R","^S",["^ ","~:keys",["~:spec-tools.visitor/visited"],"~:as","^T"]]]]]],"~:doc","Walk a spec definition. Takes 2-3 arguments, the spec and the accept\n  function, and optionally a options map, and returns the result of\n  calling the accept function. Options map can be used to pass in context-\n  specific information to to sub-visits & accepts.\n\n  The accept function is called with 4 arguments: the dispatch term for the\n  spec (see below), the spec itself, vector with the results of\n  recursively walking the children of the spec and the options map.\n\n  The dispatch term is one of the following\n  * if the spec is a function call: a fully qualified symbol for the function\n    with the following exceptions:\n    - cljs.core symbols are converted to clojure.core symbols\n    - cljs.spec.alpha symbols are converted to clojure.spec.alpha symbols\n  * if the spec is a set: :spec-tools.visitor/set\n  * otherwise: the spec itself","~:top-fn",["^ ","^Y",false,"~:fixed-arity",3,"^11",3,"^V",[["^R","^S"],["^R","^S",["^ ","^18",["^19"],"^1:","^T"]]],"^O",["^P",[["^R","^S"],["^R","^S",["^ ","^18",["^19"],"^1:","^T"]]]],"^X",["^P",[null,null]]]],"^5","~$spec-tools.visitor/visit","^I","/Users/felipe.marques/.cljs/.aot_cache/1.10.773/09B52A0/spec_tools/visitor.cljc","^M",12,"^1<",["^ ","^Y",false,"^1=",3,"^11",3,"^V",[["^R","^S"],["^R","^S",["^ ","^18",["^19"],"^1:","^T"]]],"^O",["^P",[["^R","^S"],["^R","^S",["^ ","^18",["^19"],"^1:","^T"]]]],"^X",["^P",[null,null]]],"^V",[["^R","^S"],["^R","^S",["^ ","^18",["^19"],"^1:","^T"]]],"^W",null,"^1=",3,"^X",["^P",[null,null]],"^K",1,"^Y",false,"~:methods",[["^ ","^1=",2,"^Y",false,"^15","^["],["^ ","^1=",3,"^Y",false,"^15","^["]],"^J",26,"^L",26,"^11",3,"^12",true,"^O",["^P",[["^R","^S"],["^R","^S",["^ ","^18",["^19"],"^1:","^T"]]]],"^1;","Walk a spec definition. Takes 2-3 arguments, the spec and the accept\n  function, and optionally a options map, and returns the result of\n  calling the accept function. Options map can be used to pass in context-\n  specific information to to sub-visits & accepts.\n\n  The accept function is called with 4 arguments: the dispatch term for the\n  spec (see below), the spec itself, vector with the results of\n  recursively walking the children of the spec and the options map.\n\n  The dispatch term is one of the following\n  * if the spec is a function call: a fully qualified symbol for the function\n    with the following exceptions:\n    - cljs.core symbols are converted to clojure.core symbols\n    - cljs.spec.alpha symbols are converted to clojure.spec.alpha symbols\n  * if the spec is a set: :spec-tools.visitor/set\n  * otherwise: the spec itself"],"~$visit-merge",["^ ","^G",null,"^H",["^ ","^I","/Users/felipe.marques/.cljs/.aot_cache/1.10.773/09B52A0/spec_tools/visitor.cljc","^J",70,"^K",8,"^L",70,"^M",19,"^N",true,"^O",["^P",["^Q",["^P",[["^R","^S","^T"]]]]]],"^N",true,"^5","~$spec-tools.visitor/visit-merge","^I","/Users/felipe.marques/.cljs/.aot_cache/1.10.773/09B52A0/spec_tools/visitor.cljc","^M",19,"^V",["^P",[["^R","^S","^T"]]],"^W",null,"^X",["^P",[null,null]],"^K",1,"^Y",false,"^J",70,"^Z","^[","^L",70,"^11",3,"^12",true,"^O",["^P",["^Q",["^P",[["^R","^S","^T"]]]]]],"~$spec-collector",["^ ","^G",null,"^H",["^ ","^I","/Users/felipe.marques/.cljs/.aot_cache/1.10.773/09B52A0/spec_tools/visitor.cljc","^J",152,"^K",7,"^L",152,"^M",21,"^O",["^P",["^Q",["^P",[[]]]]],"^1;","a visitor that collects all registered specs. Returns\n  a map of spec-name => spec."],"^5","~$spec-tools.visitor/spec-collector","^I","/Users/felipe.marques/.cljs/.aot_cache/1.10.773/09B52A0/spec_tools/visitor.cljc","^M",21,"^V",["^P",[[]]],"^W",null,"^X",["^P",[null,null]],"^K",1,"^Y",false,"^J",152,"^Z","~$function","^L",152,"^11",0,"^12",true,"^O",["^P",["^Q",["^P",[[]]]]],"^1;","a visitor that collects all registered specs. Returns\n  a map of spec-name => spec."]],"~:cljs.spec/registry-ref",[],"~:require-macros",["^ ","~$s","^<","^<","^<","^;","^<","^A","^@","^@","^@","^=","^>","^>","^>"],"~:cljs.analyzer/constants",["^ ","~:seen",["^4",["~:cljs.spec.alpha/unknown","~$clojure.spec.alpha/keys","~$clojure.spec.alpha/merge","~:else","~$clojure.spec.alpha/map-of","~:default","~$clojure.spec.alpha/?","~$clojure.spec.alpha/keys*","~:spec-tools.visitor/set-of","~:type","~:spec-tools.visitor/map-of","~$clojure.spec.alpha/&","~:spec-tools.visitor/vector-of","~:spec-tools.visitor/spec","~:spec-tools.visitor/default","~:spec","~$clojure.spec.alpha/and","~$clojure.spec.alpha/*","~$spec-tools.core/merge","~$clojure.spec.alpha/cat","~$clojure.spec.alpha/coll-of","~$clojure.spec.alpha/every","~$clojure.spec.alpha/alt","~$clojure.spec.alpha/+","~:spec-tools.visitor/set","^19","~$clojure.spec.alpha/every-kv","~$clojure.spec.alpha/nilable","~$clojure.spec.alpha/or","~:hierarchy","~$spec-tools.core/spec","~$clojure.spec.alpha/tuple"]],"~:order",["^1I","^25","^1L","^1N","^1W","^29","^19","^1J","^28","^1Y","^1K","^1[","^22","^26","^21","^1R","^1S","^1Q","^1U","^1M","^1Z","^24","^1O","^23","^20","^1T","^2;","^1P","^27","^2:","^1X","^1V"]],"^1;","Tools for walking spec definitions."]